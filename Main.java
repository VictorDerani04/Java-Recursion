import java.util.ArrayList;
import java.util.Arrays;

/**
 * The SkyScraper class, here we're assuming we're given an nxn board with
 *  full left/top/right/bottom hints for a traditional game of skyscraper
 *  This is given in the "hints" 2D array (which is 4xn) containing, in order
 *  left, top, right, bottom
 *
 *  For example, if our board is
 *    2   2   3   4   1
 * 2|   |   |   |   |   |1
 * 2|   |   |   |   |   |2
 * 1|   |   |   |   |   |4
 * 2|   |   |   |   |   |3
 * 3|   |   |   |   |   |2
 *    2   2   2   1   4
 *
 * Then our goal is to find the entries 1-5 on each row/column which
 *   solve the board. The solution would be
 *    2   2   3   4   1
 * 2| 4 | 2 | 3 | 1 | 5 |1
 * 2| 1 | 5 | 2 | 3 | 4 |2
 * 1| 5 | 3 | 4 | 2 | 1 |4
 * 2| 2 | 1 | 5 | 4 | 3 |3
 * 3| 3 | 4 | 1 | 5 | 2 |2
 *    2   2   2   1   4
 * n = size of skyscraper puzzle (nxn)
 * hints =  2D array of size 4xn consisting of the hints in order
 *  Left, Top, Right, Bottom (LTRB). For example
 * int hints[][] = {{2,2,1,2,3},{2,2,3,4,1},{1,2,4,3,2},{2,2,2,1,4}};
 */

class SkyScraper{

    public int hints[][];
    int n;

    /**
     * Constructor. Sets n and class variable "hints"
     * @param hints
     */
    public SkyScraper(int [][] hints, int n){
        this.hints = hints;
        this.n = n;
    }

    /**
     * Standard overridden equals for our class (autogenerated)
     * @param o
     * @return
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SkyScraper that = (SkyScraper) o;
        return n == that.n && Arrays.equals(hints, that.hints);
    }

    /**
     * checkBoard
     * @param board
     * @return true if board matches all hints, false if not
     */
    public boolean checkBoard(int [][] board){
        int max = 0;
        int counter = 0;
        //loop rows -> right to left
        for(int r = 0; r<5; r++){
            counter=0; max=0;
            for(int c = 0; c<5; c++){
                if(max<board[r][c]){
                    max = board[r][c];
                    counter++;
                }
            }

            if(counter != hints[0][r]){
                return false;
            }
        }

        //loop columns -> top to bottom
        for(int c = 0; c<5; c++){
            counter=0; max=0;
            for(int r = 0; r<5; r++){
                if(max<board[r][c]){
                    max = board[r][c];
                    counter ++;
                }
            }

            if(counter != hints[1][c]){
                return false;
            }
        }

        //loop rows -> left to right
        for(int r = 0; r<5; r++){
            counter=0; max=0;
            for(int c = 4; c>=0; c--){
                if(max<board[r][c]){
                    max = board[r][c];
                    counter++;
                }
            }

            if(counter != hints[2][r]){
                return false;
            }
        }

        //loop columns -> bottom to top
        for(int c = 0; c<5; c++){
            counter=0; max=0;
            for(int r = 4; r>=0; r--){
                if(max<board[r][c]){
                    max = board[r][c];
                    counter++;
                }
            }

            if(counter != hints[3][c]){
                return false;
            }
        }

        return true;
    }

}

/**
 * Skyscraper Solver class. Mine contains
 * perms : n! x n array consisting of every single possible permutation of n elements
 * possibleSolution: nxn array that is a possible solution to be checked
 * origs : This is kind of a temp that I use to hold n-sized 1D arrays that will
 *  go into the perms array
 * howMany : a static int that contains how many elements there are in perms
 *
 * Note: When I generate perms, I don't generate ALL permutations. I generate
 *   only ones that work with some subset of the hints
 */
class SkyscraperSolver{
    public int [][] perms;
    public int [][] possibleSoln;
    int [] origs;
    static int howMany = 0;
    public ArrayList<int[][]> allSolns; //Use only for n=6 or more

    /**
     * factorial - Recursive factorial to find full size of perms
     * @param n
     * @return
     */
    int factorial(int n){
        if(n == 1) {
            return 1;
        }
        return n*factorial(n-1);
    }

    /**
     * Constructor. Allocates for both perms and possibleSoln
     * @param n
     */
    SkyscraperSolver(int n){
        possibleSoln = new int [n][n];
        perms = new int [factorial(n)][n];
        getAllPerms(n);
    }

    /**
     * A swap routine that I use for the recursive permutation routine
     * @param x
     * @param i
     * @param j
     */
    void swap(int [] x, int i, int j){
        int temp = x[i];
        x[i] = x[j]; x[j] = temp;
    }

    /**
     * Solver. Mine is a one-liner that calls loopR. You are NOT REQUIRED
     *  to use a recursive solver, but should implement your solver inside
     *  this provided method
     * @param sky
     * @param sky
     * @param n
     */

    void solver(SkyScraper sky, int n){
        loopR(sky, n, n);
    }


    /**
     * This is the meat of my code. It recursively "builds" a row of the possible
     *  solution. Basic idea is, say, first row could be
     *  [1 2 3 4 5]
     *  Then this calls itself with "level+1" to generate the next row. It can't
     *   generate anything with a 1 in the first spot, 2 in the second, etc
     *   this continues, recursively generating every possible solution.
     *  Note that you can add in checks along the way to make sure some of the
     *   hints are satisfied to cut down on the brute force checking.
     * This code is the one and only code you DO NOT NEED TO IMPEMENT
     *  if you want to do this a different way. I'm simplying giving you my personal
     *  idea here. You're welcome to try to solve however you'd like.
     * @param sky
     * @param level
     * @param n
     */
    void loopR(SkyScraper sky,int level, int n) {
        int hintCounter = 0;
        int max = 0;
        for (int i0 = 0; i0 < perms.length; i0++) {
            hintCounter=0;
            possibleSoln[0] = perms[i0]; max=0;
            for (int i = 0; i < n; i++) {
                if (max < possibleSoln[0][i]) {
                    max = possibleSoln[0][i];
                    hintCounter++;
                }
            }
            if (hintCounter == sky.hints[0][0]) {
                for (int i1 = 0; i1 < perms.length; i1++) {
                    possibleSoln[1] = perms[i1];
                    max = 0;hintCounter=0;
                    for (int i = 0; i < n; i++) {
                        if (max < possibleSoln[1][i]) {
                            max = possibleSoln[1][i];
                            hintCounter++;
                        }
                    }
                    if (hintCounter == sky.hints[0][1]) {
                        for (int i2 = 0; i2 < perms.length; i2++) {
                            possibleSoln[2] = perms[i2];
                            max = 0;hintCounter=0;
                            for (int i = 0; i < n; i++) {
                                if (max < possibleSoln[2][i]) {
                                    max = possibleSoln[2][i];
                                    hintCounter++;
                                }
                            }
                            if (hintCounter == sky.hints[0][2]) {
                                for (int i3 = 0; i3 < perms.length; i3++) {
                                    possibleSoln[3] = perms[i3];
                                    max = 0;hintCounter=0;
                                    for (int i = 0; i < n; i++) {
                                        if (max < possibleSoln[3][i]) {
                                            max = possibleSoln[3][i];
                                            hintCounter++;
                                        }
                                    }
                                    if (hintCounter == sky.hints[0][3]) {
                                        for (int i4 = 0; i4 < perms.length; i4++) {
                                            possibleSoln[4] = perms[i4];

                                            if (sky.checkBoard(possibleSoln)) {

                                                return;
                                            } else
                                                continue;
                                        }
                                    } else
                                        continue;
                                }
                            } else
                                continue;
                        }
                    } else
                        continue;
                }
            } else
                continue;
        }
    }


    /**
     * The "Driver routine" for generating permutations. This creates a single
     *  array of size n with 1 to n ([1 2 3 4 ... n]) then generates every
     *  permutation of this and stores in "perms".
     * We do it this particular way since one can, say, enter in [1 3 5 7] and
     *  get each permutation of THAT as well, without modifying the recursive
     *  function part of the problem
     * @param n : the size of our array
     */
    void getAllPerms(int n){
        origs = new int[n];
        for(int i = 0; i<n; i++){
            origs[i] = i+1;
        }
        generatePermsR(origs, 0);
    }

    /**
     * The recursive part of the permutation generator. Here:
     * https://stackoverflow.com/questions/7537791/understanding-recursion-to-generate-permutations
     * and here:
     *
     * contains some implementations for characters, but have good descriptions
     * of the algorithm. This is what I would base mine on
     * @param x : array that contains a given permutation.
     * @param i : How many parts of the array have been chosen (i=n is "end case")
     */
    public void generatePermsR(int []x, int i){
        if(i == x.length){
            for(int j = 0; j<x.length; j++){
                perms[howMany][j] = x[j];
            }
            howMany++;
        }
        else
        {
            for (int k = i; k < x.length; k++)
            {
                swap(x,i,k);
                generatePermsR(x, i+1);
                swap(x,i,k);
            }
        }
    }

}

/**
 * Main class. We create hints and size for a known Skyscraper puzzle.
 *  Then run our solver and print out all solutions!
 * Your code should work for n=4 and n=5 (you can test on n=6, but will
 *  get  non-unique solutions.
 *
 */
public class Main {

    public static void main(String[] args) {



        int hints[][] = {{2,2,1,2,3},{2,2,3,4,1},{1,2,4,3,2},{2,2,2,1,4}};
        System.out.println("-- Possible Solutions --");

        // Print all solution here
        SkyScraper board=new SkyScraper(hints, hints[0].length);
        SkyscraperSolver solv= new SkyscraperSolver(5);
        // -- Code that can be used to time how long your code runs
        long start = System.currentTimeMillis();
        solv.solver(board,5);
        // Solver should go here, not after the long stop line
        long stop = System.currentTimeMillis();

        for(int i = 0; i < 5; i++){
            for(int j = 0; j<5; j++){
                System.out.print("| " + solv.possibleSoln[i][j] + " ");

            } System.out.println("");
        }
        System.out.println();
        System.out.println("Elapsed time: "+(stop-start)/1000.0 + " secs");

    }
}